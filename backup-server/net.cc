/**
 * @file net.cc
 */

#include "net.h"
#include "server_parsing.h"

using namespace std;

/**
 * Print an error message that combines some provided text (prefix) with the
 * standard unix error message that accompanies errno, and then exit the
 * program.  This routine makes it easier to see the logic in our program while
 * still correctly handling errors.
 *
 * @param code   The exit code to return from the program
 * @param err    The error code that was generated by the program
 * @param prefix The text to display before the error message
 */
void error_message_and_exit(std::size_t code, std::size_t err, const char *prefix) {
    char buf[1024];
    cout << strerror_r(err, buf, sizeof(buf)) << endl;
    exit(code);
}

/**
 * Create a server socket that we can use to listen for new incoming requests
 *
 * @param port The port on which the program should listen for new connections
 */
int create_server_socket(std::size_t port) {    
    /** A socket is just a kind of file descriptor.  We want our connections to use IPV4 and TCP: */
    int sd = socket(AF_INET, SOCK_STREAM, 0);
    if (sd < 0) {
        error_message_and_exit(0, errno, "Error making server socket: ");
    }
    /** The default is that when the server crashes, the socket can't be used for a few minutes. This lets us re-use the socket immediately: */
    int tmp = 1;
    if (setsockopt(sd, SOL_SOCKET, SO_REUSEADDR, &tmp, sizeof(int)) < 0) {
        close(sd);
        error_message_and_exit(0, errno, "setsockopt(SO_REUSEADDR) failed: ");
    }

    /** Bind the socket to the server's address and the provided port, and then start listening for connections */
    sockaddr_in addr;
    memset(&addr, 0, sizeof(addr));
    addr.sin_family = AF_INET;
    addr.sin_addr.s_addr = htonl(INADDR_ANY);
    addr.sin_port = htons(port);
    if (bind(sd, (struct sockaddr *)&addr, sizeof(addr)) < 0) {
        close(sd);
        error_message_and_exit(0, errno, "Error binding socket to local address: ");
    }
    if (listen(sd, 0) < 0) {
        close(sd);
        error_message_and_exit(0, errno, "Error listening on socket: ");
    }
    return sd;
}

/**
 * When a client sends a message, we use this to read from the client socket. As
 * in previous examples, we can get ourselves into some trouble if we don't know
 * how long the message is... in this case, we read up to 16 bytes at a time. In
 * a real program, we'd need to buffer each client's inputs so that we could
 * read a full message before processing it.
 *
 * @param sd The socket corresponding to the client who sent a message
 *
 * @returns True if the socket should remain open for future messages
 */
bool handle_client_input(int sd) {
    /** Receive up to 16 bytes of data... save the last byte as '\0' */
    char buf[17] = {0};
    ssize_t recd = read(sd, buf, sizeof(buf) - 1);

    /** Handle errors */
    if (recd < 0 && errno != EINTR) {
        error_message_and_exit(0, errno, "Error in read(): ");
        return false;
    }
    /** EOF means the client closed the connection */
    else if (recd == 0) { 
        return false;
    } 
    /** Otherwise, print whatever data we received */
    else {
        cout << "Message from client " << sd << ":" << buf << endl;
        return true;
    }
}

/**
 * Receive text over the provided socket file descriptor, and send it back to
 * the client.  When the client sends an EOF, return.
 *
 * @param sd      The socket file descriptor to use for the echo operation
 * @param verbose Should stats be printed upon completion?
 */
void echo_server(int sd, bool verbose) {
    /** vars for tracking connection duration, bytes transmitted */
    size_t xmitBytes = 0;
    struct timeval start_time, end_time;
    if (verbose) {
        gettimeofday(&start_time, nullptr);
    }

    /** read data for as long as there is data, and always send it back */
    while (true) {
    /** Receive up to 16 bytes of data */
        char buf[16] = {0};
        ssize_t rcd = recv(sd, buf, sizeof(buf), 0);
        if (rcd <= 0) {
            if (errno != EINTR) {
                if (rcd == 0) {
                    break;
                } 
                else {
                    /** Crash if there's a client error */
                    error_message_and_exit(0, errno, "Error in recv(): ");
                }
            }   
        } 
        else {
            /** Send back response to client */
            xmitBytes += rcd;
            char *next_byte = buf;
            std::size_t remain = rcd;
            while (remain) {
                std::size_t sent = send(sd, next_byte, remain, 0);
                if (sent <= 0) {
                    if (errno != EINTR) {
                        error_message_and_exit(0, errno, "Error in send(): ");
                    }
                } 
                else {
                    next_byte += sent;
                    remain -= sent;
                }
            }
        /** Update the transmission count */
        xmitBytes += rcd;
        }
    }
    if (verbose) {
        gettimeofday(&end_time, nullptr);
        cout << "Transmitted " << xmitBytes << " bytes in " << end_time.tv_sec - start_time.tv_sec << " seconds. " << endl;
    }
}

/**
 * @brief Print an error message that combines some application-specific text with the
 * standard unix error message that accompanies errno.
 * 
 * @param err     The error code that was generated by the program
 * @param prefix  The text to display before the error message
 */
void sys_error(int err, const char *prefix) {
    char buf[1024];
    cerr << prefix << " " << strerror_r(err, buf, sizeof(buf)) << endl;
}

/**
 * @brief Perform a reliable read when we have a guess about how many bytes we might
 * get, but it's OK if the socket EOFs before we get that many bytes.
 * 
 * @param sd   The socket from which to read
 * @param pos  The start of the vector where datashould go
 * @param amnt The maximum number of bytes to get
 * @return The actual number of bytes read, or -1 on a non-eof error 
 */
int reliable_get_to_eof_or_n(int sd, vec::iterator pos, int amnt) {
    int remain = amnt;
    unsigned char *next_byte = &*pos;
    int total = 0;
    while (remain) {
        int rcd = recv(sd, next_byte, remain, 0);
        // NB: 0 bytes received means server closed socket, and -1 means an error.
        //     EINTR means try again, otherwise we will just fail
        if (rcd <= 0) {
            if (errno != EINTR) {
                if (rcd == 0) {
                    return total;
                } else {
                    sys_error(errno, "Error in recv():");
                    return -1;
                }
            }
        } else {
            next_byte += rcd;
            remain -= rcd;
            total += rcd;
        }
    }
    return total;
}

/**
 * @brief Perform a reliable read when we are not sure how many bytes we are going to receive
 * 
 * @param sd The socket from which to read
 * @return A vector with the data that was read, or an empty vector on error 
 */
vec reliable_get_to_eof(int sd) {
    // set up the initial buffer
    vec res(16);
    int recd = 0;
    // start reading.  Double the buffer any time we fill up
    while (true) {
        int remain = res.size() - recd;
        int justgot = recv(sd, (res.data() + recd), remain, 0);
        // EOF means we're done reading
        if (justgot == 0) {
            res.resize(recd);
            return res;
        }
            // On error, fail for non-EINTR, no-op on EINTR
        else if (justgot < 0) {
            if (errno != EINTR) {
                sys_error(errno, "Error in recv():");
                return {};
            }
        }
            // bytes received.  advance pointer, maybe double the buffer
        else {
            recd += justgot;
            if (recd == (int)res.size()) {
                res.resize(2 * res.size());
            }
        }
    }
}

/**
 * @brief Given a listening socket, start calling accept() on it to get new
 * connections.  Each time a connection comes in, use the provided handler to
 * process the request.  Note that this is not multithreaded.  Only one client
 * will be served at a time.
 * 
 * @param sd      The socket file descriptor on which to call accept
 * @param handler A function to call when a new connection comes in
 */
void accept_client(int sd, function<bool(int)> handler) {
    // Use accept() to wait for a client to connect.  When it connects, service
    // it.  When it disconnects, then and only then will we accept a new client.
    while (true) {
        cout << "Waiting for a client to connect...\n";
        sockaddr_in clientAddr = {0};
        socklen_t clientAddrSize = sizeof(clientAddr);
        int connSd = accept(sd, (sockaddr *)&clientAddr, &clientAddrSize);
        if (connSd < 0) {
            close(sd);
            sys_error(errno, "Error accepting request from client: ");
            return;
        }
        char clientname[1024];
        cout << "Connected to "
             << inet_ntop(AF_INET, &clientAddr.sin_addr, clientname,
                          sizeof(clientname))
             << endl;
        bool done = handler(connSd);
        // NB: ignore errors in close()
        close(connSd);
        if (done)
            return;
    }
}

/**
 * @brief Given a listening socket, start calling accept() on it to get new
 * connections.  Each time a connection comes in, pass it to the thread pool so
 * that it can be processed.
 * 
 * @param sd    The socket file descriptor on which to call accept
 * @param pool  The thread pool that handles new requests
 */
void accept_client(int sd, thread_pool &pool) {
    // Use accept() to wait for a client to connect.  When it connects, service
    // it.  When it disconnects, then and only then will we accept a new client.
    while (true) {
        cout << "Waiting for a client to connect...\n";
        sockaddr_in clientAddr = {0};
        socklen_t clientAddrSize = sizeof(clientAddr);
        int connSd = accept(sd, (sockaddr *)&clientAddr, &clientAddrSize);
        if (connSd < 0) {
            close(sd);
            sys_error(errno, "Error accepting request from client: ");
            return;
        }
        char clientname[1024];
        cout << "Connected to "
             << inet_ntop(AF_INET, &clientAddr.sin_addr, clientname,
                          sizeof(clientname))
             << endl;
        pool.service_connection(connSd);
        // NB: ignore errors in close()
        close(connSd);
    }
}

/**
 * @brief Internal method to send a buffer of data over a socket.
 * 
 * @param sd     The socket on which to send
 * @param bytes  A pointer to the first byte of the data to send
 * @param len    The number of bytes to send
 * @return True if the whole buffer was sent, false otherwise 
 */
bool reliable_send(int sd, const unsigned char *bytes, int len) {
    // When we send, we need to be ready for the possibility that not all the
    // data will transmit at once
    const unsigned char *next_byte = bytes;
    int remain = len;
    while (remain) {
        int sent = send(sd, next_byte, remain, 0);
        // NB: Sending 0 bytes means the server closed the socket, and we should
        //     fail, so it's only EINTR that is recoverable.
        if (sent <= 0) {
            if (errno != EINTR) {
                sys_error(errno, "Error in send():");
                return false;
            }
        } else {
            next_byte += sent;
            remain -= sent;
        }
    }
    return true;
}

/**
 * @brief Send a vector of data over a socket.
 * 
 * @param sd  The socket on which to send
 * @param msg The message to send
 * @return True if the whole vector was sent, false otherwise 
 */
bool send_reliably(int sd, const vec &msg) {
    return reliable_send(sd, msg.data(), msg.size());
}

/**
 * @brief Send a string over a socket
 * 
 * @param sd  The socket on which to send
 * @param msg The message to send
 * @return True if the whole string was sent, false otherwise 
 */
bool send_reliably(int sd, const string &msg) {
    return reliable_send(sd, (const unsigned char *)msg.c_str(), msg.length());
}

/**
 * Connect to a server so that we can have bidirectional communication on the
 * socket (represented by a file descriptor) that this function returns
 *
 * @param hostname The name of the server (ip or DNS) to connect to
 * @param port     The server's port that we should use
 */
int connect_to_server(std::string hostname, std::size_t port) {
    /** Figure out IP addresses and put it in a sockaddr_in */
    struct hostent *host = gethostbyname(hostname.c_str());

    if (host == nullptr) {
        cout << "connect_to_server():DNS error: " << hstrerror(h_errno) << endl;
        exit(0);
    }

    sockaddr_in addr;
    memset(&addr, 0, sizeof(addr));
    addr.sin_family = AF_INET;
    addr.sin_addr.s_addr = inet_addr(inet_ntoa(*(struct in_addr *)*host->h_addr_list));
    addr.sin_port = htons(port);

    /** Create socket and try to connect to it */
    int sd = socket(AF_INET, SOCK_STREAM, 0);
    if (sd < 0) {
        error_message_and_exit(0, errno, "Error making client socket: ");
    }
    if (connect(sd, (sockaddr *)&addr, sizeof(addr)) < 0) {
        close(sd);
        error_message_and_exit(0, errno, "Error connecting socket to address: ");
    }
    return sd;
}
