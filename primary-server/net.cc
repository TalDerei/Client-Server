#include "net.h"

using namespace std;

/**
 * Print an error message that combines some provded text (prefix) with the
 * standard unix error message that accompanies errno, and then exit the
 * program.  This routine makes it easier to see the logic in our program while
 * still correctly handling errors.
 *
 * @param code   The exit code to return from the program
 * @param err    The error code that was generated by the program
 * @param prefix The text to display before the error message
 */
void error_message_and_exit(std::size_t code, std::size_t err, const char *prefix) {
    char buf[1024];
    cout << strerror_r(err, buf, sizeof(buf)) << endl;
    exit(code);
}

/**
 * Create a server socket that we can use to listen for new incoming requests
 *
 * @param port The port on which the program should listen for new connections
 */
int create_server_socket(std::size_t port) {    
    /** A socket is just a kind of file descriptor.  We want our connections to use IPV4 and TCP: */
    int sd = socket(AF_INET, SOCK_STREAM, 0);
    if (sd < 0) {
        error_message_and_exit(0, errno, "Error making server socket: ");
    }
    /** The default is that when the server crashes, the socket can't be used for a few minutes. This lets us re-use the socket immediately: */
    int tmp = 1;
    if (setsockopt(sd, SOL_SOCKET, SO_REUSEADDR, &tmp, sizeof(int)) < 0) {
        close(sd);
        error_message_and_exit(0, errno, "setsockopt(SO_REUSEADDR) failed: ");
    }

    /** Bind the socket to the server's address and the provided port, and then start listening for connections */
    sockaddr_in addr;
    memset(&addr, 0, sizeof(addr));
    addr.sin_family = AF_INET;
    addr.sin_addr.s_addr = htonl(INADDR_ANY);
    addr.sin_port = htons(port);
    if (bind(sd, (struct sockaddr *)&addr, sizeof(addr)) < 0) {
        close(sd);
        error_message_and_exit(0, errno, "Error binding socket to local address: ");
    }
    if (listen(sd, 0) < 0) {
        close(sd);
        error_message_and_exit(0, errno, "Error listening on socket: ");
    }
    return sd;
}

/**
 * When a client sends a message, we use this to read from the client socket. As
 * in previous examples, we can get ourselves into some trouble if we don't know
 * how long the message is... in this case, we read up to 16 bytes at a time. In
 * a real program, we'd need to buffer each client's inputs so that we could
 * read a full message before processing it.
 *
 * @param sd The socket corresponding to the client who sent a message
 *
 * @returns True if the socket should remain open for future messages
 */
bool handle_client_input(int sd) {
    /** Receive up to 16 bytes of data... save the last byte as '\0' */
    char buf[17] = {0};
    ssize_t recd = read(sd, buf, sizeof(buf) - 1);

    /** Handle errors */
    if (recd < 0 && errno != EINTR) {
        error_message_and_exit(0, errno, "Error in read(): ");
        return false;
    }
    /** EOF means the client closed the connection */
    else if (recd == 0) { 
        return false;
    } 
    /** Otherwise, print whatever data we received */
    else {
        cout << "Message from client " << sd << ":" << buf << endl;
        return true;
    }
}

/**
 * Receive text over the provided socket file descriptor, and send it back to
 * the client.  When the client sends an EOF, return.
 *
 * @param sd      The socket file descriptor to use for the echo operation
 * @param verbose Should stats be printed upon completion?
 */
void echo_server(int sd, bool verbose) {
    /** vars for tracking connection duration, bytes transmitted */
    size_t xmitBytes = 0;
    struct timeval start_time, end_time;
    if (verbose) {
        gettimeofday(&start_time, nullptr);
    }

    /** read data for as long as there is data, and always send it back */
    while (true) {
    /** Receive up to 16 bytes of data */
        char buf[16] = {0};
        ssize_t rcd = recv(sd, buf, sizeof(buf), 0);
        if (rcd <= 0) {
            if (errno != EINTR) {
                if (rcd == 0) {
                    break;
                } 
                else {
                    /** Crash if there's a client error */
                    error_message_and_exit(0, errno, "Error in recv(): ");
                }
            }   
        } 
        else {
            /** Send back response to client */
            xmitBytes += rcd;
            char *next_byte = buf;
            std::size_t remain = rcd;
            while (remain) {
                std::size_t sent = send(sd, next_byte, remain, 0);
                if (sent <= 0) {
                    if (errno != EINTR) {
                        error_message_and_exit(0, errno, "Error in send(): ");
                    }
                } 
                else {
                    next_byte += sent;
                    remain -= sent;
                }
            }
        /** Update the transmission count */
        xmitBytes += rcd;
        }
    }
    if (verbose) {
        gettimeofday(&end_time, nullptr);
        cout << "Transmitted " << xmitBytes << " bytes in " << end_time.tv_sec - start_time.tv_sec << " seconds. " << endl;
    }
}
