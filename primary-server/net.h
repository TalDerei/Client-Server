/**
 * @file net.h 
 */

#ifndef NET_SERVER_DEF
#define NET_SERVER_DEF

#include <arpa/inet.h>
#include <iostream>
#include <cstdlib>
#include <cstring>
#include <errno.h>
#include <unistd.h>
#include <stdio.h>
#include <sys/time.h>
#include <netdb.h>

#include "vec.h"
#include <functional>

/**
 * Print an error message that combines some provided text (prefix) with the
 * standard unix error message that accompanies errno, and then exit the
 * program.  This routine makes it easier to see the logic in our program while
 * still correctly handling errors.
 *
 * @param code   The exit code to return from the program
 * @param err    The error code that was generated by the program
 * @param prefix The text to display before the error message
 */
void error_message_and_exit(std::size_t, std::size_t, const char *);

/**
 * When a client sends a message, we use this to read from the client socket. As
 * in previous examples, we can get ourselves into some trouble if we don't know
 * how long the message is... in this case, we read up to 16 bytes at a time. In
 * a real program, we'd need to buffer each client's inputs so that we could
 * read a full message before processing it.
 *
 * @param sd The socket corresponding to the client who sent a message
 *
 * @returns True if the socket should remain open for future messages
 */
bool handle_client_input(int);

/**
 * Receive text over the provided socket file descriptor, and send it back to
 * the client.  When the client sends an EOF, return.
 *
 * @param sd      The socket file descriptor to use for the echo operation
 * @param verbose Should stats be printed upon completion?
 */
void echo_server(int, bool);

/**
 * Create a server socket that we can use to listen for new incoming requests
 *
 * @param port The port on which the program should listen for new connections
 */
int create_server_socket(std::size_t);

/**
 * @brief Print an error message that combines some application-specific text with the
 * standard unix error message that accompanies errno.
 * 
 * @param err     The error code that was generated by the program
 * @param prefix  The text to display before the error message
 */
void sys_error(int err, const char *prefix);

/**
 * @brief Perform a reliable read when we have a guess about how many bytes we might
 * get, but it's OK if the socket EOFs before we get that many bytes.
 * 
 * @param sd   The socket from which to read
 * @param pos  The start of the vector where datashould go
 * @param amnt The maximum number of bytes to get
 * @return The actual number of bytes read, or -1 on a non-eof error 
 */
int reliable_get_to_eof_or_n(int sd, vec::iterator pos, int amnt);

/**
 * @brief Perform a reliable read when we are not sure how many bytes we are going to receive
 * 
 * @param sd The socket from which to read
 * @return A vector with the data that was read, or an empty vector on error 
 */
vec reliable_get_to_eof(int sd);

/**
 * @brief Given a listening socket, start calling accept() on it to get new
 * connections.  Each time a connection comes in, use the provided handler to
 * process the request.  Note that this is not multithreaded.  Only one client
 * will be served at a time.
 * 
 * @param sd      The socket file descriptor on which to call accept
 * @param handler A function to call when a new connection comes in
 */
void accept_client(int sd, std::function<bool(int)> handler);

/**
 * @brief Internal method to send a buffer of data over a socket.
 * 
 * @param sd     The socket on which to send
 * @param bytes  A pointer to the first byte of the data to send
 * @param len    The number of bytes to send
 * @return True if the whole buffer was sent, false otherwise 
 */
bool reliable_send(int sd, const unsigned char *bytes, int len);

/**
 * @brief Send a vector of data over a socket.
 * 
 * @param sd  The socket on which to send
 * @param msg The message to send
 * @return True if the whole vector was sent, false otherwise 
 */
bool send_reliably(int sd, const vec &msg);

/**
 * @brief Send a string over a socket
 * 
 * @param sd  The socket on which to send
 * @param msg The message to send
 * @return True if the whole string was sent, false otherwise 
 */
bool send_reliably(int sd, const std::string &msg);

/**
 * @brief Connect to primary or backup server
 *
 * @param name The name of the server (ip or DNS) to connect to
 * @param port The server's port that we shoul duse
 * @return     int
 */
int connect_to_server(std::string name, size_t port);

#endif